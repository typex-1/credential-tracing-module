<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8">
  <title>AuditableBlindCA - Preparation</title>
  
  <link rel="stylesheet" href="normalize.min.css">
  <link rel="stylesheet" href="style.css">
  <!-- Fonts -->
  <link href='roboto.css' rel='stylesheet' type='text/css'>
  <link href="font.min.css" rel="stylesheet" type="text/css">
  <!-- // Fonts -->
  
  <script type="text/javascript" src= "jquery.min.js"></script>
  <script type="text/javascript" src= "app.js"></script>
  
</head>
<body>
		<!-- Vertical Timeline -->
		<section id="conference-timeline">
		<div class="container">
		<ol class="timeline">
		<li>
		<p class="lined">Preparation </p>
		<a href = "index" id = "a_index"><span class="pointed"></span></a>
		</li>

		<li>
		<p class="line">Issuing</p>
		<a href = "issuing" id = "a_issuing"><span class="point"></span></a>
		</li>

		<li>
		<p class="line">Verifying</p>
		<a href = "verifying" id = "a_verifying"><span class="point"></span></a>
		</li>

		<li>
		<p class="line">Tracing</p>
		<a href = "tracing.html" id = "a_tracing" ><span class="point"></span></a>
		</li>
		</ol>
		</div>

		<b>Version: Elliptic Curve Cryptography <i class="fab fa-expeditedssl"></i> </b> <br> <br>
		1. Set up parameters &nbsp;&nbsp;&nbsp;&nbsp;
		
		<!-- <select name="jumpMenu" id="selectParam"> 
		<option value="secp256k1">secp256k1</option> 
		<option value="secp192k1">secp192k1</option> 
		</select> -->
		
		<input style= "cursor: default; opacity: 0.2" type="radio" name="secp" id = "secp256k1" value="secp256k1" checked>secp256k1 <i class="fa fa-check-circle fa-check" id ="isecp256k1" style = "display:none"></i>
		&nbsp;&nbsp;&nbsp;&nbsp; |
        <input style= "cursor: default; opacity: 0.2" type="radio" name="secp" id = "secp192k1" value="secp192k1">secp192k1 <i class="fa fa-check-circle fa-check" id ="isecp192k1" style = "display:none"></i>
		 
		<hr>
		<!-- Article -->
		<div class="timeline-article">
		<div class="content-left-container">
		<div class="content-left"> 
		<p><span class="article-number">Issuer</span>
		<label for="description">a = </label><span class=""><input id = "a1"></input></span><br>
		<label for="description">b = </label><span class=""><input id = "b1"></input></span><br>
		<label for="description">p = </label><span class=""><input id = "p1"></input></span><br>
		<label for="description">n = </label><span class=""><input id = "n1"></input></span><br> 
		<label for="description">g = </label><span class=""><input id = "g1"></input></span><br>
		<label for="description">h = </label><span class=""><input id = "h1"></input></span><br> 
		</p>
		</div>
		<span class="timeline-author"></span>
		</div>
		<div class="content-right-container">

		<div class="content-right">
		<p> <span class="article-number">User</span>
		<label for="description">a = </label><span class=""><input id = "a2"></input></span><br>
		<label for="description">b = </label><span class=""><input id = "b2"></input></span><br>
		<label for="description">p = </label><span class=""><input id = "p2"></input></span><br>
		<label for="description">n = </label><span class=""><input id = "n2"></input></span><br> 
		<label for="description">g = </label><span class=""><input id = "g2"></input></span><br>
		<label for="description">h = </label><span class=""><input id = "h2"></input></span><br> 
		</p>
		</div>

		</div>
		<!--<div class="meta-date">
		<span class="date">&rarr;</span>
		</div>
		-->
		</div>
		<!-- // Article --> 
		
		2. Key Generation
		<hr>
		
		<!-- Article -->
		<div class="timeline-article">
		<div class="content-left-container">
		<div class="content-left">
		<p class = "sp">
		
		Please click <a href = "javascript: void(0)" class="" id = "issuerkey" style= "cursor: default; opacity: 0.2" >here</a> to generation issuer's public key and private key.<br>
		<label class="textdescription">x <font color = "red">(private)</font> = </label> <span class=""><input id = "x"></input></span><br>
		<label class="textdescription">y (public) = xP = </label>             <span class=""><input id = "y"></input></span><br>
		<label class="textdescription">&#918; = &#919;<sub>1</sub>(g,h,y) = </label> <span class=""><input id = "z1"></input></span><br>
		</p>
		</div>

		</div>
		<div class="content-right-container">
		<div class="content-right">
		<p class = "sp">
		
		Please click <a href = "javascript: void(0)" class="" id = "userkey" style= "cursor: default; opacity: 0.2" >here</a> to generation user's public key and private key.<br>
		<label class="textdescription">&#955; <font color = "red">(private)</font>  = </label><span class=""><input id = "gamma"></input></span><br>
		<label class="textdescription">&#958; (public) = &#955;P = </label><span class=""><input id = "xi"></input></span><br>
		<label class="textdescription">&#918; = &#919;<sub>1</sub>(g,h,y) = </label><span class=""><input id = "z2"></input></span><br>
		</p>
		</div>
		<!-- <span class="timeline-author">John Doe</span> -->
		</div>
		<!-- <div class="meta-date">
		<span class="date">&larr;</span>
		</div> -->
		</div>
        <!-- // Article -->
		
        3. Smart Contract Registration
		<hr>
	    <b>Please do the following steps to deploy the privacy-preserving smart contract and register the parameters</b> <br><br>
	    
	    <div style = "width:100%; background: #e9ecef;">
			<div class="timeline-wrapper" >
			  <div class="node" id = "node1" style = "display: ''">
				<h3><span class="myicon-tick-checked" id = "myicon1"></span></h3>
				<p> 3.1.Please <a href = "javascript: void(0)" class="" id = "confirm" style= "cursor: default; opacity: 0.2" >ensure</a> that you have installed the <a href = "https://metamask.io/" target = "_blank" > MetaMask </a> environment. 
				<br> <br> 
				<div id = "check-status" class="alert alert-success" style="display:none;width: 80%">
				Your MetaMask wallet is installed well and your address is <a href = "" target = "_blank" id = "ac_addrsss">1</a>
				</div> 
				</p>
			  </div>
			  
			  <div class="node" id = "node2" style = "display: ''">
				<h3><span class="myicon-tick-uncheck" id = "myicon2"></span></h3>
				<p> 3.2.  Please check the below certificate-tracer smart contract, we recommend you to use <a href = "https://remix.ethereum.org/#optimize=false&version=builtin"> Remix </a> to analysis and debug the code.</p>
			  		<textarea rows=7 cols=100 readonly style = "width: 99%" >
pragma solidity ^0.4.18;
contract AuditTracer {
    
    uint256 public gx;
    uint256 public gy;
    uint256 public p;
	uint256 public n;
    uint256 public a;
    uint256 public b;
 
    // The address of the account that created this ballot.
    address public tracerCreator;
    mapping (address => uint256) private CredentialTraceTimes;
    mapping (address => uint256) private CredentialTraceResults;
    
    mapping (address => uint256) private IdentityTraceTimes;
    mapping (address => uint256) private IdentityTraceResults;
	
    uint256 public seed = 0;
    uint256 private xt;
    
    uint256 public yt_x;
    uint256 public yt_y;
    
    uint256 private c_x;
    uint256 private c_y;
    
    uint256 private i_x;
    uint256 private i_y;
    
    constructor() public {
        tracerCreator = msg.sender;
    }
 
    event trace_log(
        string information,
        address indexed sender,
        uint256 timestamp,
        uint256 calltimes,
        uint256 obj
    );
    
    function credential_tracing_log(uint256 obj) internal {
         emit trace_log("credential_tracing_log", msg.sender, now, CredentialTraceTimes[msg.sender], obj);
    }
    
    function identity_tracing_log(uint256 obj) internal {
         emit trace_log("credential_tracing_log", msg.sender, now, IdentityTraceTimes[msg.sender], obj);
    }
	
	function register_parameter(uint256 _a, uint256 _b, uint256 _p, uint256 _n, uint256 _gx, uint256 _gy) public{ 
		a = _a;
		b = _b;
		p = _p;
		n = _n;
		gx = _gx;
		gy = _gy;
        xt = rand_less_than(_n);
    }
    
    function get_private_key() public view returns(uint256){  
		return xt;
	}
    
    function calculate_public_key() public{  
        (yt_x, yt_y) = multiplyScalar(gx, gy, xt);
	}
	
	function get_public_key() public view returns(uint256 , uint256 ){  
		return (yt_x, yt_y);
	}
	
	function credential_tracing() public returns(uint256,uint256){
	        CredentialTraceTimes[msg.sender] += 1;
	    return (c_x,c_y);
	}
	
	function identity_tracing() public returns(uint256,uint256){
	        CredentialTraceTimes[msg.sender] += 1;
	     return (i_x,i_y);
	}

	// trace the credential
    function credential_calculating(uint256 xiupsilon_x, uint256 xiupsilon_y) public{
	    if (CredentialTraceTimes[msg.sender] == 0){
            (c_x,c_y) = multiplyScalar(xiupsilon_x, xiupsilon_y, xt);
        }
        credential_tracing_log(xiupsilon_x);
    }
    
    // trace the identity
    function identity_calculating(uint256 zeta1_x, uint256 zeta1_y) public{
        if (IdentityTraceTimes[msg.sender] == 0){
            uint256 nxt = inverseMod(xt, n);
            (i_x,i_y) = multiplyScalar(zeta1_x, zeta1_y, nxt);	
        }
        identity_tracing_log(zeta1_x);
    }
    
    function rand_less_than(uint256 upper_bound) private returns(uint256){
        uint256 r = PRNG() % upper_bound;
		return r;
    }
    
    function PRNG() private view returns(uint256) {
        return uint256(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty,msg.sender,now)))) ;
    }

    /**
     * @dev Inverse of u in the field of modulo m.
     */
    function inverseMod(uint u, uint m) internal pure
        returns (uint)
    {
        if (u == 0 || u == m || m == 0)
            return 0;
        if (u > m)
            u = u % m;

        int t1;
        int t2 = 1;
        uint r1 = m;
        uint r2 = u;
        uint q;

        while (r2 != 0) {
            q = r1 / r2;
            (t1, t2, r1, r2) = (t2, t1 - int(q) * t2, r2, r1 - q * r2);
        }

        if (t1 < 0)
            return (m - uint(-t1));

        return uint(t1);
    }

    /**
     * @dev Transform affine coordinates into projective coordinates.
     */
    function toProjectivePoint(uint x0, uint y0) public view
        returns (uint[3] memory P)
    {
        P[2] = addmod(0, 1, p);
        P[0] = mulmod(x0, P[2], p);
        P[1] = mulmod(y0, P[2], p);
    }

    /**
     * @dev Add two points in affine coordinates and return projective point.
     */
    function addAndReturnProjectivePoint(uint x1, uint y1, uint x2, uint y2) public view
        returns (uint[3] memory P)
    {
        uint x;
        uint y;
        (x, y) = add(x1, y1, x2, y2);
        P = toProjectivePoint(x, y);
    }

    /**
     * @dev Transform from projective to affine coordinates.
     */
    function toAffinePoint(uint x0, uint y0, uint z0) public view
        returns (uint x1, uint y1)
    {
        uint z0Inv;
        z0Inv = inverseMod(z0, p);
        x1 = mulmod(x0, z0Inv, p);
        y1 = mulmod(y0, z0Inv, p);
    }

    /**
     * @dev Return the zero curve in projective coordinates.
     */
    function zeroProj() public view
        returns (uint x, uint y, uint z)
    {
        return (0, 1, 0);
    }

    /**
     * @dev Return the zero curve in affine coordinates.
     */
    function zeroAffine() public pure
        returns (uint x, uint y)
    {
        return (0, 0);
    }

    /**
     * @dev Check if the curve is the zero curve.
     */
    function isZeroCurve(uint x0, uint y0) public view
        returns (bool isZero)
    {
        if(x0 == 0 && y0 == 0) {
            return true;
        }
        return false;
    }

    /**
     * @dev Check if a point in affine coordinates is on the curve.
     */
    function isOnCurve(uint x, uint y) public view
        returns (bool)
    {
        if (0 == x || x == p || 0 == y || y == p) {
            return false;
        }

        uint LHS = mulmod(y, y, p); // y^2
        uint RHS = mulmod(mulmod(x, x, p), x, p); // x^3

        if (a != 0) {
            RHS = addmod(RHS, mulmod(x, a, p), p); // x^3 + a*x
        }
        if (b != 0) {
            RHS = addmod(RHS, b, p); // x^3 + a*x + b
        }

        return LHS == RHS;
    }

    /**
     * @dev Double an elliptic curve point in projective coordinates. See
     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates
     */
    function twiceProj(uint x0, uint y0, uint z0) public view
        returns (uint x1, uint y1, uint z1)
    {
        uint t;
        uint u;
        uint v;
        uint w;

        if(isZeroCurve(x0, y0)) {
            return zeroProj();
        }

        u = mulmod(y0, z0, p);
        u = mulmod(u, 2, p);

        v = mulmod(u, x0, p);
        v = mulmod(v, y0, p);
        v = mulmod(v, 2, p);

        x0 = mulmod(x0, x0, p);
        t = mulmod(x0, 3, p);

        z0 = mulmod(z0, z0, p);
        z0 = mulmod(z0, a, p);
        t = addmod(t, z0, p);

        w = mulmod(t, t, p);
        x0 = mulmod(2, v, p);
        w = addmod(w, p-x0, p);

        x0 = addmod(v, p-w, p);
        x0 = mulmod(t, x0, p);
        y0 = mulmod(y0, u, p);
        y0 = mulmod(y0, y0, p);
        y0 = mulmod(2, y0, p);
        y1 = addmod(x0, p-y0, p);

        x1 = mulmod(u, w, p);

        z1 = mulmod(u, u, p);
        z1 = mulmod(z1, u, p);
    }

    /**
     * @dev Add two elliptic curve points in projective coordinates. See
     * https://www.nayuki.io/page/elliptic-curve-point-addition-in-projective-coordinates
     */
    function addProj(uint x0, uint y0, uint z0, uint x1, uint y1, uint z1) public view
        returns (uint x2, uint y2, uint z2)
    {
        uint t0;
        uint t1;
        uint u0;
        uint u1;

        if (isZeroCurve(x0, y0)) {
            return (x1, y1, z1);
        }
        else if (isZeroCurve(x1, y1)) {
            return (x0, y0, z0);
        }

        t0 = mulmod(y0, z1, p);
        t1 = mulmod(y1, z0, p);

        u0 = mulmod(x0, z1, p);
        u1 = mulmod(x1, z0, p);

        if (u0 == u1) {
            if (t0 == t1) {
                return twiceProj(x0, y0, z0);
            }
            else {
                return zeroProj();
            }
        }

        (x2, y2, z2) = addProj2(mulmod(z0, z1, p), u0, u1, t1, t0);
    }

    /**
     * @dev Helper function that splits addProj to avoid too many local variables.
     */
    function addProj2(uint v, uint u0, uint u1, uint t1, uint t0) private view
        returns (uint x2, uint y2, uint z2)
    {
        uint u;
        uint u2;
        uint u3;
        uint w;
        uint t;

        t = addmod(t0, p-t1, p);
        u = addmod(u0, p-u1, p);
        u2 = mulmod(u, u, p);

        w = mulmod(t, t, p);
        w = mulmod(w, v, p);
        u1 = addmod(u1, u0, p);
        u1 = mulmod(u1, u2, p);
        w = addmod(w, p-u1, p);

        x2 = mulmod(u, w, p);

        u3 = mulmod(u2, u, p);
        u0 = mulmod(u0, u2, p);
        u0 = addmod(u0, p-w, p);
        t = mulmod(t, u0, p);
        t0 = mulmod(t0, u3, p);

        y2 = addmod(t, p-t0, p);

        z2 = mulmod(u3, v, p);
    }

    /**
     * @dev Add two elliptic curve points in affine coordinates.
     */
    function add(uint x0, uint y0, uint x1, uint y1) public view
        returns (uint, uint)
    {
        uint z0;

        (x0, y0, z0) = addProj(x0, y0, 1, x1, y1, 1);

        return toAffinePoint(x0, y0, z0);
    }

    /**
     * @dev Double an elliptic curve point in affine coordinates.
     */
    function twice(uint x0, uint y0) public view
        returns (uint, uint)
    {
        uint z0;

        (x0, y0, z0) = twiceProj(x0, y0, 1);

        return toAffinePoint(x0, y0, z0);
    }

    /**
     * @dev Multiply an elliptic curve point by a 2 power base (i.e., (2^exp)*P)).
     */
    function multiplyPowerBase2(uint x0, uint y0, uint exp) public view
        returns (uint, uint)
    {
        uint base2X = x0;
        uint base2Y = y0;
        uint base2Z = 1;

        for(uint i = 0; i < exp; i++) {
            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);
        }

        return toAffinePoint(base2X, base2Y, base2Z);
    }

    /**
     * @dev Multiply an elliptic curve point by a scalar.
     */
    function multiplyScalar(uint x0, uint y0, uint scalar) public view
        returns (uint x1, uint y1)
    {
        if(scalar == 0) {
            return zeroAffine();
        }
        else if (scalar == 1) {
            return (x0, y0);
        }
        else if (scalar == 2) {
            return twice(x0, y0);
        }

        uint base2X = x0;
        uint base2Y = y0;
        uint base2Z = 1;
        uint z1 = 1;
        x1 = x0;
        y1 = y0;

        if(scalar%2 == 0) {
            x1 = y1 = 0;
        }

        scalar = scalar >> 1;

        while(scalar > 0) {
            (base2X, base2Y, base2Z) = twiceProj(base2X, base2Y, base2Z);

            if(scalar%2 == 1) {
                (x1, y1, z1) = addProj(base2X, base2Y, base2Z, x1, y1, z1);
            }

            scalar = scalar >> 1;
        }

        return toAffinePoint(x1, y1, z1);
    }

    /**
     * @dev Multiply the curve's generator point by a scalar.
     */
    function multipleGeneratorByScalar(uint scalar) public view
        returns (uint, uint)
    {
        return multiplyScalar(gx, gy, scalar);
    }
}
					</textarea>
			  
			  
			  </div>
			  <div class="node" id = "node3" style = "display: ''">
				<h3><span class="myicon-tick-uncheck" id = "myicon3"></span></h3>
				<p> 3.3. Please click <a href = "javascript: void(0)" class="" onclick="deploy()" >here</a> to compile and deploy the smart contract. 
				<br> <br> 
				<div id = "compile-status" class="alert alert-success" style="display:none;width: 80%">
				The smart contract is compiled successfully. The compiled code is <input id = "sm_code"></input>
				</div> 
				
				<div id = "deploy-status" class="alert alert-success" style="display:none;width: 80%">
				The smart contract is deployed successfully. The address is <a href = "" target = "_blank" id = "sm_addrsss"></a>
				</div>
				</p>
			  </div>
			  <div class="node" id = "node4" style = "display: ''">
				<h3><span class="myicon-tick-uncheck" id = "myicon4"></span></h3>
				<p>3.4. Please click <a href = "javascript: void(0)" onclick="register()" id = "register_parameter">here</a> to register parameters to the privacy-preserving smart contract. <br><br>
				<div id = "register-status" class="alert alert-success" style="display:none;width: 80%">
				The parameters are registered successfully.
				</div>
				</p>
			  </div>
			  <div class="node" id = "node5" style = "display: ''">
				<h3><span class="myicon-tick-uncheck" id = "myicon5"></span></h3>
				<p>3.5. Please click <a href = "javascript: void(0)" onclick="get_public_key()" >here</a> to get the tracer's public key. <br><br>
				    <div id = "publickey-status" class="alert alert-success" style="display:none;width: 80%">
					Ttracer's public key is obtained successfully and tracer's public key is <input id = "yt"></input>
					</div>
			    </p>
			  </div>
			  
			  <div class="node" id = "node6" style = "display: ''">
				<h3><span class="myicon-tick-uncheck" id = "myicon6"></span></h3>
				<p>3.6. Congratulations!!!,  you finished all the registrations. Please click <a href = "" id = "issueCred">here</a> to continue 
				next issuing steps. 
			  </div>
			  
			</div>
		</div>
	  <br><br>
	  4. Identity Registration(optional)
		<hr>
    
    <!-- <div class="timeline-end">End</div> -->
  </section>
  <!-- // Vertical Timeline -->
  
  <div id="copyright">
        <p>&copy; Copyright 2019 Rujia. All Rights Reserved</p>
  </div>
</body>
</html>